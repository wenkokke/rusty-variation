\documentclass[sigconf,UKEnglish,natbib=false]{acmart}
\input{preamble}

\begin{document}
\title{Rusty Variation}
\subtitle{Deadlock-free Sessions with Failure in Rust}
\author{Wen Kokke}
\authornote{%
  Graduate student (8450698), supervised by Philip Wadler and Ian Stark.}
\affiliation{%
  LFCS, University of Edinburgh, 10 Crichton St,
  EH8 9AB, Edinburgh, United Kingdom}
\email{wen.kokke@ed.ac.uk}

\begin{abstract}
  Rusty Variation (RV) is a library for session-typed communication in Rust which offers strong compile-time correctness guarantees. Programs written using RV are guaranteed to respect a specified protocol, and are guaranteed to be free from deadlocks and races.
\end{abstract}

\maketitle

\section*{Problem \& Motivation}
In concurrent programming, processes commonly exchange information by sending messages on shared channels. However, this communication often does not follow a specified protocol, and if it does, it the correctness of the implementation with respect to that protocol is rarely checked.

Session types are a substructural typing discipline, introduced by \textcite{honda1993}, which describe communication protocols as \emph{channel types}, capturing both the type and the order of messages. Session type systems, then, ensure that programs correctly implement specified protocols.

Rust is an immensely popular systems programming language.\footnote{https://insights.stackoverflow.com/survey/2018/} It aims to combine efficiency with abstraction and thread and memory safety. However, out of the box, it does not offer a way to specify protocols and verify communication.

In this paper, we present Rusty Variation, a library for session-typed communication in Rust which allows users to specify and check the adherence to communication protocols, in addition to offering strong correctness guarantees, such as freedom from deadlocks and races.
We assume some familiarity with Rust. For an introduction to Rust, we refer the reader to \textit{The Rust Programming Language}.\footnote{\url{https://doc.rust-lang.org/nightly/book/}}

\section*{Background \& Related Work}
\Textcite{jespersen2015} implement session types in Rust, based on the session-typed functional language LAST by \textcite{gay2009}. Their implementation guarantees that programs correctly implement specified communication protocols with some caveats. LAST depends upon linear types, meaning that sessions have to be used exactly once. Rust only offers affine types, meaning that  values---and, particularly relevant here, sessions---can be dropped. The implementation of LAST in Rust, therefore, guarantees session fidelity under the assumption that channels are \emph{never dropped}. In some cases, the compiler can be made to issue a warning at compile-time when a channel is dropped, for instance through the \texttt{\#[must\_use]} annotation. However, in general, this is not something the compiler can guarantee. Furthermore, LAST ignores the possibility of communication failures, such as network errors, which cannot be detected at compile-time, yet can cause a channel to be dropped.

We embrace the affine, and base our work on Exceptional GV by \textcite[EGV]{fowler2018}. Exceptional GV is a descendant of Good Variation~\parencite[GV]{wadler2012}, which itself is a descendant of LAST. Crucially, EGV has an affine type system, and allows for the explicit cancellation of sessions. Furthermore, EGV offers a stronger metatheory than LAST. In addition to session fidelity, EGV also guarantees global progress, freedom from deadlocks and livelocks, confluence, and termination. That is to say, there are no locks or race conditions, and all programs eventually halt. For a discussion of EGV and its metatheory, we refer the reader to the work by \textcite{fowler2018}.

\section*{Contribution: Rusty Variation}
Our contribution, Rusty Variation, is an implementation of EGV in Rust. We claim that it is a faithful implementation, which preserves much of EGVs metatheory. However, we depart from it in two ways:

First, EGV relies upon exceptions and handlers. Rust, however, has rejected exceptions in favour of monadic errors i.e., wrapping possibly failing results in error types such as \lstinline{Option<T>} and \lstinline{Result<T,E>}.

Second, the core language of EGV does not include general recursion. Rust does. In the presence of non-termination, we cannot guarantee session fidelity, livelock freedom, or---well---termination. The work by \textcite{jespersen2015} also suffers from this shortcoming. We can demonstrate this by writing the program which loops forever, and then sends a message. The Rust type checker does not see a problem with this, but obviously the message will never be sent. However, we claim that if the program terminates, it respected the communication protocol.

\subsection*{Sessions and duality}
Any type built using the primitive types below is a valid session:
\begin{lstlisting}
pub struct End;
pub struct Send<T, S: Session>{ ... }
pub struct Recv<T, S: Session>{ ... }
\end{lstlisting}
Session \emph{types} are public, but their members are not. Therefore, user cannot construct their own misbehaving sessions. The continuation of a session must itself be a session. This is enforced by the \lstinline{Session} constraint. In addition to this ``kinding'' of session types, the \lstinline{Session} trait also implements duality and session generation:
\begin{lstlisting}
pub trait Session {
  type Dual: Session<Dual=Self>;
  fn new() -> (Self, Self::Dual);
}
\end{lstlisting}
Duality works as expected: \lstinline{Send<T, S>} is dual to \lstinline{Recv<T, S::Dual>}---and vice versa---and \lstinline{End} is self-dual.
The constraint \lstinline{Session<Dual=Self>} enforces that the dual of a
session is a session, and that \lstinline{S::Dual::Dual} is equal to \lstinline{S} (involutivity).

The \lstinline{new} function generates a new session and returns two \emph{dual} channel endpoints. Unlike the rest of the functions discussed in this section, \lstinline{new} is \emph{not} part of the public interface.

Using these types, we can define the types of servers which offer negation and addition as follows, where \lstinline{i32} is the type of 32-bit integers:
\begin{lstlisting}
type NegSrv = Recv<i32, Send<i32, End>>;
type AddSrv = Recv<i32, Recv<i32, Send<i32, End>>>;
\end{lstlisting}
The client types are obtained by duality.

\subsection*{Send, receive, and fork!}
The \lstinline{send} and \lstinline{recv} functions send and receive values in sessions. They have the following types:
\begin{lstlisting}
pub fn send<T, S: Session>(x: T, s: Send<T, S>)
       -> Result<S, Box<Error>>;
pub fn recv<T, S: Session>(s: Recv<T, S)
       -> Result<(T, S), Box<Error>>;
\end{lstlisting}
The \lstinline{fork!} macro creates a new session, and spawns a new thread. The new thread runs the first argument of \lstinline{fork!}---a code block---which receives one endpoint, and \lstinline{fork!} returns the dual endpoint. While \lstinline{fork!} is implemented as a macro, it can be considered as a function with the following type:
\begin{lstlisting}
pub fn fork!<S: Session>(p: P) -> S::Dual
      where
        P: FnOnce(S) -> Result<(), Box<Error>>;
\end{lstlisting}
Using these primitives, we can write the following program. This program forks off a process which sends a ``ping'' along the session, then waits to receive that ping and returns:
\begin{lstlisting}
let s = fork!(move |s: Send<(), End>| { send((), s) });
let ((), End) = recv(s)?;
Ok(())
\end{lstlisting}
The \lstinline{let x = M?;} construct is Rust's ``monadic bind'' notation for programs which may return errors. If \lstinline{recv(s)} fails, the \lstinline{?}-operator short-circuits, skips the rest of the statements, and returns the error.

\subsection*{Cancellation}
The \lstinline{cancel} function drops a value and cancels all sessions \emph{and} their duals referenced in that value. This cancellation propagates: any process attempting to write or write to a cancelled channel will return fail and cancel all \emph{their} open channels. This ensures that no process is left waiting for a message that will never come.
\begin{lstlisting}
pub fn cancel<T>(x: T) -> Result<(), Box<Error>>;
\end{lstlisting}
Using \lstinline{cancel}, we can implement the following program. This program forks off a process which it \emph{expects} to send a ``ping''. However, instead the forked process cancels the session. Therefore, the call to \lstinline{recv} fails, the \lstinline{?}-operator short-circuits, and the whole process returns an error:
\begin{lstlisting}
let s = fork!(move |s: Send<(), End>| { cancel(s) });
let (z, End) = recv(s)?;
Ok(())
\end{lstlisting}
The cancellation mechanism is implemented through destructors. In fact, in the current implementation it is inherited from the implementation of channels in \lstinline{std::sync::mpsc}.

The \lstinline{Send} and \lstinline{Recv} structures are annotated with \lstinline{#[must_use]}, to encourage the user to complete the protocol or cancel it explicitly. However, should a session be dropped, this is interpreted as \emph{implicit} cancellation. This ensures deadlock freedom, even in Rust's affine type system.

\subsection*{Branching with offer! and select!}
The \lstinline{offer_either}, \lstinline{select_left}, and \lstinline{select_right} functions let processes offer or make a \emph{binary} choice. They implement this by receiving or sending a value of the sum type \lstinline{Either<S1, S2>}, where \lstinline{S1} and \lstinline{S2} are the possible continuations of the session. For instance, we could write the type of a ``calculator'' server, offering negation and addition, as \lstinline{Recv<Either<NegSrv, AddSrv>, End>}.

While these functions suffice to encode choice, we also define two macros, \lstinline{offer!} and \lstinline{select!}, which generalise this functionality to \emph{all enums}---as long as each value wraps a session. This allows processes to offer and select choices between many \emph{labelled} branches, and allows us to define the type for our calculator server as:
\begin{lstlisting}
type CalcSrv = Recv<CalcOp, End>;
enum CalcOp {Neg(NegSrv), Add(AddSrv)}
\end{lstlisting}
Using these macros, we can write the following program. This program forks off a calculator server, which offers the choice between negation and addition, selects addition, sends some numbers, and then returns the result:
\begin{lstlisting}
let s = fork!(move |s: CalcSrv| {
  offer!(s, {
    CalcOp::Neg(s) => {
      let (x, s) = recv(s)?;
      send(-x, s)
    },
    CalcOp::Add(s) => {
      let (x, s) = recv(s)?;
      let (y, s) = recv(s)?;
      send(x + y, s)
    },
  })
});
let s = select!(CalcOp::Add, s)?;
let s = send(4, s)?;
let s = send(5, s)?;
let (z, End) = recv(s)?;
Ok(z)
\end{lstlisting}

\subsection*{Limitations}
There are two issues which can make code written using Rusty Variation deadlock, and surprisingly, \lstinline{unsafe} is not one of them:

The biggest issue lies in the fact that Rust's semantics do not guarantee that destructors are actually run. For instance, it is always possible to ``forget'' a value, using \lstinline{std::mem::forget}, without running its destructors. The following simple program deadlocks:
\begin{lstlisting}
let s = fork!(move |s: Send<(), End>| { mem::forget(s) });
let ((), End) = recv(s)?;
Ok(())
\end{lstlisting}

Second, it is not possible---at the moment---to export a trait without exporting all its members. Therefore, any user can use the \lstinline{new} function, and doing so, it is trivial to write a program which deadlocks: 
\begin{lstlisting}
let (s1, r1) = Send<Void, End>::new();
let r2 = fork!(move |s2: Send<Void, End>| {
  let (v, End) = recv(r1)?;
  send(v, s2)
});
let (v, End) = recv(r2)?;
send(v, s1)
\end{lstlisting}

Last, the implementation Rusty Variation is inefficient. We currently use the asynchronous channels from \lstinline{std::sync::mpsc}. These are ideal, as they already implement the correct cancellation behaviour. Unfortunately, they can send values of only a single type. Therefore, in the implementation of \lstinline{send}, we create a new session for the continuation, and send that along with the value. This means we create a ``one-shot'' channel for every call to \lstinline{send}.

\clearpage
\printbibliography
\end{document}